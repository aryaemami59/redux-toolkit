diff --git a/dist/rollup-plugin-dts.cjs b/dist/rollup-plugin-dts.cjs
index dc20a86a3284644fecab961f2a58a2f06ff3c1bc..483641d376fea67ebbd87b5722fb6942be5c2e86 100644
--- a/dist/rollup-plugin-dts.cjs
+++ b/dist/rollup-plugin-dts.cjs
@@ -171,6 +171,160 @@ function createPrograms(input, overrideOptions, tsconfig) {
     return programs;
 }
 
+class ExportsFixer {
+    constructor(source) {
+        this.source = source;
+        this.DEBUG = !!process.env.DTS_EXPORTS_FIXER_DEBUG;
+    }
+    fix() {
+        const exports = this.findExports();
+        exports.sort((a, b) => a.location.start - b.location.start);
+        return this.getCodeParts(exports).join("");
+    }
+    findExports() {
+        const { rawExports, values, types, uniqueSymbols } = this.getExportsAndLocals();
+        return rawExports.map((rawExport) => {
+            const elements = rawExport.elements
+                .filter((e) => !uniqueSymbols.map((f) => f.getText()).includes(e.getText()))
+                .map((e) => {
+                const exportedName = e.name.text;
+                const localName = e.propertyName?.text ?? e.name.text;
+                const kind = types.some((node) => node.getText() === localName) && !values.some((node) => node.getText() === localName)
+                    ? "type"
+                    : // : uniqueSymbols.some((node) => node.getText() === localName)
+                        // ? ("unique-symbol" as const)
+                        "value";
+                this.DEBUG && console.log(`export ${localName} as ${exportedName} is a ${kind}`);
+                return {
+                    exportedName,
+                    localName,
+                    kind,
+                };
+            });
+            return {
+                location: {
+                    start: rawExport.getStart(),
+                    end: rawExport.getEnd(),
+                },
+                exports: elements,
+            };
+        });
+    }
+    getExportsAndLocals(statements = this.source.statements) {
+        const rawExports = [];
+        const values = [];
+        const types = [];
+        const uniqueSymbols = [];
+        const recurseInto = (subStatements) => {
+            const { rawExports: subExports, values: subValues, types: subTypes, uniqueSymbols: subUniqueSymbols, } = this.getExportsAndLocals(subStatements);
+            rawExports.push(...subExports);
+            values.push(...subValues);
+            types.push(...subTypes);
+            uniqueSymbols.push(...subUniqueSymbols);
+        };
+        for (const statement of statements) {
+            this.DEBUG && console.log(statement.getText(), statement.kind);
+            if (ts.isImportDeclaration(statement)) {
+                continue;
+            }
+            if (ts.isInterfaceDeclaration(statement) || ts.isTypeAliasDeclaration(statement)) {
+                this.DEBUG && console.log(`${statement.name.getFullText()} is a type`);
+                types.push(statement.name);
+                continue;
+            }
+            if (ts.isEnumDeclaration(statement) ||
+                ts.isFunctionDeclaration(statement) ||
+                ts.isClassDeclaration(statement) ||
+                ts.isVariableStatement(statement)) {
+                if (ts.isVariableStatement(statement)) {
+                    for (const declaration of statement.declarationList.declarations) {
+                        if (ts.isIdentifier(declaration.name)) {
+                            if (declaration.type?.kind === ts.SyntaxKind.TypeOperator &&
+                                ts.isTypeOperatorNode(declaration.type) &&
+                                declaration.type.operator === ts.SyntaxKind.UniqueKeyword) {
+                                uniqueSymbols.push(declaration.name);
+                                // break;
+                            }
+                            else {
+                                this.DEBUG && console.log(`${declaration.name.getFullText()} is a value (from var statement)`);
+                                values.push(declaration.name);
+                            }
+                        }
+                    }
+                }
+                else {
+                    if (statement.name) {
+                        this.DEBUG && console.log(`${statement.name.getFullText()} is a value (from declaration)`);
+                        values.push(statement.name);
+                    }
+                }
+                continue;
+            }
+            if (ts.isModuleBlock(statement)) {
+                const subStatements = statement.statements;
+                recurseInto(subStatements);
+                continue;
+            }
+            if (ts.isModuleDeclaration(statement)) {
+                if (statement.name && ts.isIdentifier(statement.name)) {
+                    this.DEBUG && console.log(`${statement.name.getFullText()} is a value (from module declaration)`);
+                    values.push(statement.name);
+                }
+                recurseInto(statement.getChildren());
+                continue;
+            }
+            if (ts.isExportDeclaration(statement)) {
+                if (statement.moduleSpecifier) {
+                    continue;
+                }
+                if (statement.isTypeOnly) {
+                    // no fixup neccessary
+                    continue;
+                }
+                const exportClause = statement.exportClause;
+                if (!exportClause || !ts.isNamedExports(exportClause)) {
+                    continue;
+                }
+                rawExports.push(exportClause);
+                continue;
+            }
+            this.DEBUG && console.log("unhandled statement", statement.getFullText(), statement.kind);
+        }
+        return {
+            rawExports,
+            values,
+            types,
+            uniqueSymbols,
+        };
+    }
+    createNamedExport(exportSpec, elideType = false) {
+        return `${!elideType && exportSpec.kind === "type" ? "type " : ""}${exportSpec.localName}${exportSpec.localName === exportSpec.exportedName ? "" : ` as ${exportSpec.exportedName}`}`;
+    }
+    getCodeParts(exports) {
+        let cursor = 0;
+        const code = this.source.getFullText();
+        const parts = [];
+        for (const exportDeclaration of exports) {
+            const head = code.slice(cursor, exportDeclaration.location.start);
+            if (head.length > 0) {
+                parts.push(head);
+            }
+            parts.push(this.getExportStatement(exportDeclaration));
+            cursor = exportDeclaration.location.end;
+        }
+        if (cursor < code.length) {
+            parts.push(code.slice(cursor));
+        }
+        return parts;
+    }
+    getExportStatement(exportDeclaration) {
+        const isTypeOnly = exportDeclaration.exports.every((e) => e.kind === "type") && exportDeclaration.exports.length > 0;
+        return `${isTypeOnly ? "type " : ""}{ ${exportDeclaration.exports
+            .map((exp) => this.createNamedExport(exp, isTypeOnly))
+            .join(", ")} }`;
+    }
+}
+
 function getCodeFrame() {
     let codeFrameColumns = undefined;
     try {
@@ -814,6 +968,19 @@ function fixModifiers(code, node) {
     if (!ts.canHaveModifiers(node)) {
         return;
     }
+    if (ts.isVariableStatement(node)) {
+        const modifier = node.modifiers?.[0];
+        const declaration = node.declarationList.declarations[0];
+        if (modifier &&
+            modifier.kind === ts.SyntaxKind.ExportKeyword &&
+            declaration &&
+            ts.isIdentifier(declaration.name) &&
+            declaration.type &&
+            ts.isTypeOperatorNode(declaration.type) &&
+            declaration.type.operator === ts.SyntaxKind.UniqueKeyword) {
+            return;
+        }
+    }
     let hasDeclare = false;
     const needsDeclare = ts.isEnumDeclaration(node) ||
         ts.isClassDeclaration(node) ||
@@ -1490,137 +1657,6 @@ class Transformer {
     }
 }
 
-class ExportsFixer {
-    constructor(source) {
-        this.source = source;
-        this.DEBUG = !!(process.env.DTS_EXPORTS_FIXER_DEBUG);
-    }
-    fix() {
-        const exports = this.findExports();
-        exports.sort((a, b) => a.location.start - b.location.start);
-        return this.getCodeParts(exports).join('');
-    }
-    findExports() {
-        const { rawExports, values, types } = this.getExportsAndLocals();
-        return rawExports.map((rawExport) => {
-            const elements = rawExport.elements.map((e) => {
-                const exportedName = e.name.text;
-                const localName = e.propertyName?.text ?? e.name.text;
-                const kind = types.some(node => node.getText() === localName) && !values.some(node => node.getText() === localName) ? 'type' : 'value';
-                this.DEBUG && (console.log(`export ${localName} as ${exportedName} is a ${kind}`));
-                return {
-                    exportedName,
-                    localName,
-                    kind
-                };
-            });
-            return {
-                location: {
-                    start: rawExport.getStart(),
-                    end: rawExport.getEnd(),
-                },
-                exports: elements
-            };
-        });
-    }
-    getExportsAndLocals(statements = this.source.statements) {
-        const rawExports = [];
-        const values = [];
-        const types = [];
-        const recurseInto = (subStatements) => {
-            const { rawExports: subExports, values: subValues, types: subTypes } = this.getExportsAndLocals(subStatements);
-            rawExports.push(...subExports);
-            values.push(...subValues);
-            types.push(...subTypes);
-        };
-        for (const statement of statements) {
-            this.DEBUG && console.log(statement.getText(), statement.kind);
-            if (ts.isImportDeclaration(statement)) {
-                continue;
-            }
-            if (ts.isInterfaceDeclaration(statement) || ts.isTypeAliasDeclaration(statement)) {
-                this.DEBUG && console.log(`${statement.name.getFullText()} is a type`);
-                types.push(statement.name);
-                continue;
-            }
-            if (ts.isEnumDeclaration(statement) ||
-                ts.isFunctionDeclaration(statement) ||
-                ts.isClassDeclaration(statement) ||
-                ts.isVariableStatement(statement)) {
-                if (ts.isVariableStatement(statement)) {
-                    for (const declaration of statement.declarationList.declarations) {
-                        if (ts.isIdentifier(declaration.name)) {
-                            this.DEBUG && console.log(`${declaration.name.getFullText()} is a value (from var statement)`);
-                            values.push(declaration.name);
-                        }
-                    }
-                }
-                else {
-                    if (statement.name) {
-                        this.DEBUG && console.log(`${statement.name.getFullText()} is a value (from declaration)`);
-                        values.push(statement.name);
-                    }
-                }
-                continue;
-            }
-            if (ts.isModuleBlock(statement)) {
-                const subStatements = statement.statements;
-                recurseInto(subStatements);
-                continue;
-            }
-            if (ts.isModuleDeclaration(statement)) {
-                if (statement.name && ts.isIdentifier(statement.name)) {
-                    this.DEBUG && console.log(`${statement.name.getFullText()} is a value (from module declaration)`);
-                    values.push(statement.name);
-                }
-                recurseInto(statement.getChildren());
-                continue;
-            }
-            if (ts.isExportDeclaration(statement)) {
-                if (statement.moduleSpecifier) {
-                    continue;
-                }
-                if (statement.isTypeOnly) {
-                    // no fixup neccessary
-                    continue;
-                }
-                const exportClause = statement.exportClause;
-                if (!exportClause || !ts.isNamedExports(exportClause)) {
-                    continue;
-                }
-                rawExports.push(exportClause);
-                continue;
-            }
-            this.DEBUG && console.log('unhandled statement', statement.getFullText(), statement.kind);
-        }
-        return { rawExports, values, types };
-    }
-    createNamedExport(exportSpec, elideType = false) {
-        return `${!elideType && exportSpec.kind === 'type' ? 'type ' : ''}${exportSpec.localName}${exportSpec.localName === exportSpec.exportedName ? '' : ` as ${exportSpec.exportedName}`}`;
-    }
-    getCodeParts(exports) {
-        let cursor = 0;
-        const code = this.source.getFullText();
-        const parts = [];
-        for (const exportDeclaration of exports) {
-            const head = code.slice(cursor, exportDeclaration.location.start);
-            if (head.length > 0) {
-                parts.push(head);
-            }
-            parts.push(this.getExportStatement(exportDeclaration));
-            cursor = exportDeclaration.location.end;
-        }
-        if (cursor < code.length) {
-            parts.push(code.slice(cursor));
-        }
-        return parts;
-    }
-    getExportStatement(exportDeclaration) {
-        const isTypeOnly = exportDeclaration.exports.every((e) => e.kind === 'type') && exportDeclaration.exports.length > 0;
-        return `${isTypeOnly ? 'type ' : ''}{ ${exportDeclaration.exports.map((exp) => this.createNamedExport(exp, isTypeOnly)).join(', ')} }`;
-    }
-}
-
 function parse(fileName, code) {
     return ts.createSourceFile(fileName, code, ts.ScriptTarget.Latest, true);
 }
@@ -1744,15 +1780,25 @@ function writeBlock(codes) {
 }
 
 const TS_EXTENSIONS = /\.([cm]ts|[tj]sx?)$/;
-function getModule({ programs, resolvedOptions: { compilerOptions, tsconfig } }, fileName, code) {
+function getModule({ entries, programs, resolvedOptions: { compilerOptions, tsconfig } }, fileName, code) {
     // Create any `ts.SourceFile` objects on-demand for ".d.ts" modules,
     // but only when there are zero ".ts" entry points.
     if (!programs.length && DTS_EXTENSIONS.test(fileName)) {
         return { code };
     }
+    const isEntry = entries.includes(fileName);
     // Rollup doesn't tell you the entry point of each module in the bundle,
     // so we need to ask every TypeScript program for the given filename.
-    const existingProgram = programs.find((p) => !!p.getSourceFile(fileName));
+    const existingProgram = programs.find((p) => {
+        // Entry points may be in the other entry source files, but it can't emit from them.
+        // So we should find the program about the entry point which is the root files.
+        if (isEntry) {
+            return p.getRootFileNames().includes(fileName);
+        }
+        else {
+            return !!p.getSourceFile(fileName);
+        }
+    });
     if (existingProgram) {
         // we know this exists b/c of the .filter above, so this non-null assertion is safe
         const source = existingProgram.getSourceFile(fileName);
@@ -1780,7 +1826,7 @@ function getModule({ programs, resolvedOptions: { compilerOptions, tsconfig } },
 }
 const plugin = (options = {}) => {
     const transformPlugin = transform();
-    const ctx = { programs: [], resolvedOptions: resolveDefaultOptions(options) };
+    const ctx = { entries: [], programs: [], resolvedOptions: resolveDefaultOptions(options) };
     return {
         name: "dts",
         // pass outputOptions & renderChunk hooks to the inner transform plugin
@@ -1868,6 +1914,8 @@ const plugin = (options = {}) => {
         },
         resolveId(source, importer) {
             if (!importer) {
+                // store the entry point, because we need to know which program to add the file
+                ctx.entries.push(path__namespace.resolve(source));
                 return;
             }
             // normalize directory separators to forward slashes, as apparently typescript expects that?
diff --git a/dist/rollup-plugin-dts.mjs b/dist/rollup-plugin-dts.mjs
index ef394ab8c1ecb5f29f2842dab77808a5003568f2..3a3b169410c858745bf42390b9e29104e3cf11b8 100644
--- a/dist/rollup-plugin-dts.mjs
+++ b/dist/rollup-plugin-dts.mjs
@@ -147,6 +147,160 @@ function createPrograms(input, overrideOptions, tsconfig) {
     return programs;
 }
 
+class ExportsFixer {
+    constructor(source) {
+        this.source = source;
+        this.DEBUG = !!process.env.DTS_EXPORTS_FIXER_DEBUG;
+    }
+    fix() {
+        const exports = this.findExports();
+        exports.sort((a, b) => a.location.start - b.location.start);
+        return this.getCodeParts(exports).join("");
+    }
+    findExports() {
+        const { rawExports, values, types, uniqueSymbols } = this.getExportsAndLocals();
+        return rawExports.map((rawExport) => {
+            const elements = rawExport.elements
+                .filter((e) => !uniqueSymbols.map((f) => f.getText()).includes(e.getText()))
+                .map((e) => {
+                const exportedName = e.name.text;
+                const localName = e.propertyName?.text ?? e.name.text;
+                const kind = types.some((node) => node.getText() === localName) && !values.some((node) => node.getText() === localName)
+                    ? "type"
+                    : // : uniqueSymbols.some((node) => node.getText() === localName)
+                        // ? ("unique-symbol" as const)
+                        "value";
+                this.DEBUG && console.log(`export ${localName} as ${exportedName} is a ${kind}`);
+                return {
+                    exportedName,
+                    localName,
+                    kind,
+                };
+            });
+            return {
+                location: {
+                    start: rawExport.getStart(),
+                    end: rawExport.getEnd(),
+                },
+                exports: elements,
+            };
+        });
+    }
+    getExportsAndLocals(statements = this.source.statements) {
+        const rawExports = [];
+        const values = [];
+        const types = [];
+        const uniqueSymbols = [];
+        const recurseInto = (subStatements) => {
+            const { rawExports: subExports, values: subValues, types: subTypes, uniqueSymbols: subUniqueSymbols, } = this.getExportsAndLocals(subStatements);
+            rawExports.push(...subExports);
+            values.push(...subValues);
+            types.push(...subTypes);
+            uniqueSymbols.push(...subUniqueSymbols);
+        };
+        for (const statement of statements) {
+            this.DEBUG && console.log(statement.getText(), statement.kind);
+            if (ts.isImportDeclaration(statement)) {
+                continue;
+            }
+            if (ts.isInterfaceDeclaration(statement) || ts.isTypeAliasDeclaration(statement)) {
+                this.DEBUG && console.log(`${statement.name.getFullText()} is a type`);
+                types.push(statement.name);
+                continue;
+            }
+            if (ts.isEnumDeclaration(statement) ||
+                ts.isFunctionDeclaration(statement) ||
+                ts.isClassDeclaration(statement) ||
+                ts.isVariableStatement(statement)) {
+                if (ts.isVariableStatement(statement)) {
+                    for (const declaration of statement.declarationList.declarations) {
+                        if (ts.isIdentifier(declaration.name)) {
+                            if (declaration.type?.kind === ts.SyntaxKind.TypeOperator &&
+                                ts.isTypeOperatorNode(declaration.type) &&
+                                declaration.type.operator === ts.SyntaxKind.UniqueKeyword) {
+                                uniqueSymbols.push(declaration.name);
+                                // break;
+                            }
+                            else {
+                                this.DEBUG && console.log(`${declaration.name.getFullText()} is a value (from var statement)`);
+                                values.push(declaration.name);
+                            }
+                        }
+                    }
+                }
+                else {
+                    if (statement.name) {
+                        this.DEBUG && console.log(`${statement.name.getFullText()} is a value (from declaration)`);
+                        values.push(statement.name);
+                    }
+                }
+                continue;
+            }
+            if (ts.isModuleBlock(statement)) {
+                const subStatements = statement.statements;
+                recurseInto(subStatements);
+                continue;
+            }
+            if (ts.isModuleDeclaration(statement)) {
+                if (statement.name && ts.isIdentifier(statement.name)) {
+                    this.DEBUG && console.log(`${statement.name.getFullText()} is a value (from module declaration)`);
+                    values.push(statement.name);
+                }
+                recurseInto(statement.getChildren());
+                continue;
+            }
+            if (ts.isExportDeclaration(statement)) {
+                if (statement.moduleSpecifier) {
+                    continue;
+                }
+                if (statement.isTypeOnly) {
+                    // no fixup neccessary
+                    continue;
+                }
+                const exportClause = statement.exportClause;
+                if (!exportClause || !ts.isNamedExports(exportClause)) {
+                    continue;
+                }
+                rawExports.push(exportClause);
+                continue;
+            }
+            this.DEBUG && console.log("unhandled statement", statement.getFullText(), statement.kind);
+        }
+        return {
+            rawExports,
+            values,
+            types,
+            uniqueSymbols,
+        };
+    }
+    createNamedExport(exportSpec, elideType = false) {
+        return `${!elideType && exportSpec.kind === "type" ? "type " : ""}${exportSpec.localName}${exportSpec.localName === exportSpec.exportedName ? "" : ` as ${exportSpec.exportedName}`}`;
+    }
+    getCodeParts(exports) {
+        let cursor = 0;
+        const code = this.source.getFullText();
+        const parts = [];
+        for (const exportDeclaration of exports) {
+            const head = code.slice(cursor, exportDeclaration.location.start);
+            if (head.length > 0) {
+                parts.push(head);
+            }
+            parts.push(this.getExportStatement(exportDeclaration));
+            cursor = exportDeclaration.location.end;
+        }
+        if (cursor < code.length) {
+            parts.push(code.slice(cursor));
+        }
+        return parts;
+    }
+    getExportStatement(exportDeclaration) {
+        const isTypeOnly = exportDeclaration.exports.every((e) => e.kind === "type") && exportDeclaration.exports.length > 0;
+        return `${isTypeOnly ? "type " : ""}{ ${exportDeclaration.exports
+            .map((exp) => this.createNamedExport(exp, isTypeOnly))
+            .join(", ")} }`;
+    }
+}
+
 function getCodeFrame() {
     let codeFrameColumns = undefined;
     try {
@@ -790,6 +944,19 @@ function fixModifiers(code, node) {
     if (!ts.canHaveModifiers(node)) {
         return;
     }
+    if (ts.isVariableStatement(node)) {
+        const modifier = node.modifiers?.[0];
+        const declaration = node.declarationList.declarations[0];
+        if (modifier &&
+            modifier.kind === ts.SyntaxKind.ExportKeyword &&
+            declaration &&
+            ts.isIdentifier(declaration.name) &&
+            declaration.type &&
+            ts.isTypeOperatorNode(declaration.type) &&
+            declaration.type.operator === ts.SyntaxKind.UniqueKeyword) {
+            return;
+        }
+    }
     let hasDeclare = false;
     const needsDeclare = ts.isEnumDeclaration(node) ||
         ts.isClassDeclaration(node) ||
@@ -1466,137 +1633,6 @@ class Transformer {
     }
 }
 
-class ExportsFixer {
-    constructor(source) {
-        this.source = source;
-        this.DEBUG = !!(process.env.DTS_EXPORTS_FIXER_DEBUG);
-    }
-    fix() {
-        const exports = this.findExports();
-        exports.sort((a, b) => a.location.start - b.location.start);
-        return this.getCodeParts(exports).join('');
-    }
-    findExports() {
-        const { rawExports, values, types } = this.getExportsAndLocals();
-        return rawExports.map((rawExport) => {
-            const elements = rawExport.elements.map((e) => {
-                const exportedName = e.name.text;
-                const localName = e.propertyName?.text ?? e.name.text;
-                const kind = types.some(node => node.getText() === localName) && !values.some(node => node.getText() === localName) ? 'type' : 'value';
-                this.DEBUG && (console.log(`export ${localName} as ${exportedName} is a ${kind}`));
-                return {
-                    exportedName,
-                    localName,
-                    kind
-                };
-            });
-            return {
-                location: {
-                    start: rawExport.getStart(),
-                    end: rawExport.getEnd(),
-                },
-                exports: elements
-            };
-        });
-    }
-    getExportsAndLocals(statements = this.source.statements) {
-        const rawExports = [];
-        const values = [];
-        const types = [];
-        const recurseInto = (subStatements) => {
-            const { rawExports: subExports, values: subValues, types: subTypes } = this.getExportsAndLocals(subStatements);
-            rawExports.push(...subExports);
-            values.push(...subValues);
-            types.push(...subTypes);
-        };
-        for (const statement of statements) {
-            this.DEBUG && console.log(statement.getText(), statement.kind);
-            if (ts.isImportDeclaration(statement)) {
-                continue;
-            }
-            if (ts.isInterfaceDeclaration(statement) || ts.isTypeAliasDeclaration(statement)) {
-                this.DEBUG && console.log(`${statement.name.getFullText()} is a type`);
-                types.push(statement.name);
-                continue;
-            }
-            if (ts.isEnumDeclaration(statement) ||
-                ts.isFunctionDeclaration(statement) ||
-                ts.isClassDeclaration(statement) ||
-                ts.isVariableStatement(statement)) {
-                if (ts.isVariableStatement(statement)) {
-                    for (const declaration of statement.declarationList.declarations) {
-                        if (ts.isIdentifier(declaration.name)) {
-                            this.DEBUG && console.log(`${declaration.name.getFullText()} is a value (from var statement)`);
-                            values.push(declaration.name);
-                        }
-                    }
-                }
-                else {
-                    if (statement.name) {
-                        this.DEBUG && console.log(`${statement.name.getFullText()} is a value (from declaration)`);
-                        values.push(statement.name);
-                    }
-                }
-                continue;
-            }
-            if (ts.isModuleBlock(statement)) {
-                const subStatements = statement.statements;
-                recurseInto(subStatements);
-                continue;
-            }
-            if (ts.isModuleDeclaration(statement)) {
-                if (statement.name && ts.isIdentifier(statement.name)) {
-                    this.DEBUG && console.log(`${statement.name.getFullText()} is a value (from module declaration)`);
-                    values.push(statement.name);
-                }
-                recurseInto(statement.getChildren());
-                continue;
-            }
-            if (ts.isExportDeclaration(statement)) {
-                if (statement.moduleSpecifier) {
-                    continue;
-                }
-                if (statement.isTypeOnly) {
-                    // no fixup neccessary
-                    continue;
-                }
-                const exportClause = statement.exportClause;
-                if (!exportClause || !ts.isNamedExports(exportClause)) {
-                    continue;
-                }
-                rawExports.push(exportClause);
-                continue;
-            }
-            this.DEBUG && console.log('unhandled statement', statement.getFullText(), statement.kind);
-        }
-        return { rawExports, values, types };
-    }
-    createNamedExport(exportSpec, elideType = false) {
-        return `${!elideType && exportSpec.kind === 'type' ? 'type ' : ''}${exportSpec.localName}${exportSpec.localName === exportSpec.exportedName ? '' : ` as ${exportSpec.exportedName}`}`;
-    }
-    getCodeParts(exports) {
-        let cursor = 0;
-        const code = this.source.getFullText();
-        const parts = [];
-        for (const exportDeclaration of exports) {
-            const head = code.slice(cursor, exportDeclaration.location.start);
-            if (head.length > 0) {
-                parts.push(head);
-            }
-            parts.push(this.getExportStatement(exportDeclaration));
-            cursor = exportDeclaration.location.end;
-        }
-        if (cursor < code.length) {
-            parts.push(code.slice(cursor));
-        }
-        return parts;
-    }
-    getExportStatement(exportDeclaration) {
-        const isTypeOnly = exportDeclaration.exports.every((e) => e.kind === 'type') && exportDeclaration.exports.length > 0;
-        return `${isTypeOnly ? 'type ' : ''}{ ${exportDeclaration.exports.map((exp) => this.createNamedExport(exp, isTypeOnly)).join(', ')} }`;
-    }
-}
-
 function parse(fileName, code) {
     return ts.createSourceFile(fileName, code, ts.ScriptTarget.Latest, true);
 }
@@ -1720,15 +1756,25 @@ function writeBlock(codes) {
 }
 
 const TS_EXTENSIONS = /\.([cm]ts|[tj]sx?)$/;
-function getModule({ programs, resolvedOptions: { compilerOptions, tsconfig } }, fileName, code) {
+function getModule({ entries, programs, resolvedOptions: { compilerOptions, tsconfig } }, fileName, code) {
     // Create any `ts.SourceFile` objects on-demand for ".d.ts" modules,
     // but only when there are zero ".ts" entry points.
     if (!programs.length && DTS_EXTENSIONS.test(fileName)) {
         return { code };
     }
+    const isEntry = entries.includes(fileName);
     // Rollup doesn't tell you the entry point of each module in the bundle,
     // so we need to ask every TypeScript program for the given filename.
-    const existingProgram = programs.find((p) => !!p.getSourceFile(fileName));
+    const existingProgram = programs.find((p) => {
+        // Entry points may be in the other entry source files, but it can't emit from them.
+        // So we should find the program about the entry point which is the root files.
+        if (isEntry) {
+            return p.getRootFileNames().includes(fileName);
+        }
+        else {
+            return !!p.getSourceFile(fileName);
+        }
+    });
     if (existingProgram) {
         // we know this exists b/c of the .filter above, so this non-null assertion is safe
         const source = existingProgram.getSourceFile(fileName);
@@ -1756,7 +1802,7 @@ function getModule({ programs, resolvedOptions: { compilerOptions, tsconfig } },
 }
 const plugin = (options = {}) => {
     const transformPlugin = transform();
-    const ctx = { programs: [], resolvedOptions: resolveDefaultOptions(options) };
+    const ctx = { entries: [], programs: [], resolvedOptions: resolveDefaultOptions(options) };
     return {
         name: "dts",
         // pass outputOptions & renderChunk hooks to the inner transform plugin
@@ -1844,6 +1890,8 @@ const plugin = (options = {}) => {
         },
         resolveId(source, importer) {
             if (!importer) {
+                // store the entry point, because we need to know which program to add the file
+                ctx.entries.push(path.resolve(source));
                 return;
             }
             // normalize directory separators to forward slashes, as apparently typescript expects that?
